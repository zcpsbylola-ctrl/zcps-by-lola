Parfait ! On va intégrer le pinch-to-zoom tactile directement dans le bloc React/TypeScript final. Je vais te fournir tout le code complet en un seul bloc Markdown, avec la logique de :

Multi-jours infini Timeline 24h Sélection minute-level (hh:00 / hh:15 / hh:30 / hh:45) Buffer 75 min grisé automatiquement Bouton Valider → WhatsApp Pinch-to-zoom tactile, avec labels qui apparaissent progressivement selon le zoom # ZCPS by Lola — React + TypeScript — Version Mobile Luxe Finale avec Pinch-to-Zoom ## Structure projet Vite 

my-reservation-app/ │ ├─ index.html ├─ vite.config.ts ├─ package.json ├─ tsconfig.json ├─ src/ │ ├─ main.tsx │ ├─ App.tsx │ ├─ components/ │ │ ├─ Timeline.tsx │ │ ├─ DayColumn.tsx │ │ └─ Slot.tsx │ └─ styles.css

--- ## src/App.tsx ```tsx import React, { useState } from 'react'; import Timeline from './components/Timeline'; const App: React.FC = () => { const [selected, setSelected] = useState<{day:number,minute:number}|null>(null); const handleValidate = () => { if(!selected) return; const now=new Date(); const date=new Date( now.getFullYear(), now.getMonth(), now.getDate()+selected.day, Math.floor(selected.minute/60), selected.minute%60 ).toLocaleString(); const whatsappUrl=`https://wa.me/33605656753?text=${encodeURIComponent( `Bonjour,\nJe souhaite réserver le créneau du ${date}.\nMerci ✨` )}`; window.location.href=whatsappUrl; } return ( <> <h2>Ze agenda de réZervation by Lola</h2> <Timeline selected={selected} setSelected={setSelected}/> <button onClick={handleValidate} disabled={!selected}>Valider</button> </> ) } export default App; src/components/Timeline.tsx import React, { useState, useEffect, useRef } from 'react'; import DayColumn from './DayColumn'; interface TimelineProps{ selected: {day:number,minute:number}|null; setSelected: React.Dispatch<React.SetStateAction<{day:number,minute:number}|null>>; } const MINUTES_IN_DAY = 24*60; const Timeline: React.FC<TimelineProps> = ({selected,setSelected}) => { const [timeline,setTimeline] = useState<any[][]>([]); const [startDayOffset,setStartDayOffset] = useState(0); const [zoomLevel,setZoomLevel] = useState(1); // 1 = default, 2=zoom in const containerRef = useRef<HTMLDivElement>(null); useEffect(()=>{ const initial:any[][]=[]; for(let i=0;i<3;i++){ initial.push(Array.from({length:MINUTES_IN_DAY},(_,m)=>({day:i,minute:m,blocked:false}))); } setTimeline(initial); },[]); useEffect(()=>{ const el=containerRef.current; if(!el) return; const handleScroll = ()=>{ if(el.scrollLeft+el.clientWidth>=el.scrollWidth-100){ const nextDayOffset = startDayOffset + timeline.length; setTimeline(prev=>[...prev, Array.from({length:MINUTES_IN_DAY},(_,m)=>({day:nextDayOffset,minute:m,blocked:false}))]); } }; el.addEventListener('scroll',handleScroll); return ()=>el.removeEventListener('scroll',handleScroll); },[timeline,startDayOffset]); // Pinch-to-zoom useEffect(()=>{ const el=containerRef.current; if(!el) return; let initialDistance: number|null = null; const handleTouchMove = (e: TouchEvent)=>{ if(e.touches.length!==2) return; const [t1,t2]=e.touches; const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY); if(initialDistance===null){ initialDistance = dist; return; } const scale = dist/initialDistance; if(scale>1.1) setZoomLevel(prev=>Math.min(prev+1,4)); else if(scale<0.9) setZoomLevel(prev=>Math.max(prev-1,1)); initialDistance=dist; }; const handleTouchEnd = (e: TouchEvent)=>{ initialDistance=null; }; el.addEventListener('touchmove',handleTouchMove); el.addEventListener('touchend',handleTouchEnd); el.addEventListener('touchcancel',handleTouchEnd); return ()=>{ el.removeEventListener('touchmove',handleTouchMove); el.removeEventListener('touchend',handleTouchEnd); el.removeEventListener('touchcancel',handleTouchEnd); } },[]); const handleSelect=(day:number,minute:number)=>{ if(timeline[day][minute].blocked) return; setSelected({day,minute}); setTimeline(prev=>{ const newTimeline=prev.map(row=>row.map(slot=>({...slot}))); let total=75,d=day,m=minute; while(total>0 && d<newTimeline.length){ const remaining=MINUTES_IN_DAY-m; const count=Math.min(total,remaining); for(let i=0;i<count;i++){ newTimeline[d][m+i].blocked=true; } total-=count; d+=1; m=0; } return newTimeline; }); } return ( <div className="days-container" ref={containerRef}> {timeline.map((daySlots,di)=>( <DayColumn key={di} slots={daySlots} selected={selected} onSelect={handleSelect} zoomLevel={zoomLevel}/> ))} </div> ) }; export default Timeline; src/components/DayColumn.tsx import React from 'react'; import Slot from './Slot'; interface DayColumnProps{ slots:any[]; selected:{day:number,minute:number}|null; onSelect:(day:number,minute:number)=>void; zoomLevel:number; } const DayColumn:React.FC<DayColumnProps>=({slots,selected,onSelect,zoomLevel})=>{ return ( <div className="day-column"> {slots.map(slot=>( <Slot key={slot.minute} slot={slot} selected={selected} onSelect={onSelect} zoomLevel={zoomLevel}/> ))} </div> ) } export default DayColumn; src/components/Slot.tsx import React from 'react'; interface SlotProps{ slot:any; selected:{day:number,minute:number}|null; onSelect:(day:number,minute:number)=>void; zoomLevel:number; } const Slot:React.FC<SlotProps>=({slot,selected,onSelect,zoomLevel})=>{ const isSelected=selected?.day===slot.day && selected?.minute===slot.minute; const showLabel = slot.minute % Math.max(15/zoomLevel,1) === 0; return ( <div className={`slot ${slot.blocked?'blocked':''} ${isSelected?'selected':''}`} onClick={()=>onSelect(slot.day,slot.minute)}> <span className={`slot-label ${showLabel?'show-label':''}`}> {showLabel?`${String(Math.floor(slot.minute/60)).padStart(2,'0')}:${String(slot.minute%60).padStart(2,'0')}`:''} </span> </div> ) } export default Slot; src/styles.css body{ margin:0; font-family:'Inter',sans-serif; background:#1a1a2e; color:#f0f0f0; -webkit-tap-highlight-color:transparent; } h2{text-align:center;margin:10px 0;color:#f0f0f0;text-shadow:0 1px 3px rgba(0,0,0,0.5);} .days-container{display:flex;overflow-x:auto;scroll-snap-type:x mandatory;-webkit-overflow-scrolling:touch;padding:10px;min-height:600px;} .day-column{display:flex;flex-direction:column;min-width:70px;margin-right:6px;scroll-snap-align:start;} .slot{height:22px;margin:1px 0;border-radius:4px;background-color:#7f8c8d;transition:0.2s ease;flex-shrink:0;position:relative;} .slot.selected{background:linear-gradient(90deg,#ffd700,#ffb700);border-radius:6px;box-shadow:0 0 6px rgba(255,215,0,0.6);} .slot.blocked{background-color: rgba(0,0,0,0.25); pointer-events:none;} .slot-label{position:absolute;left:6px;top:0;font-size:10px;color:#e0e0ff;opacity:0;transition:0.15s ease;} .slot.show-label .slot-label{opacity:1;} button{margin:12px auto;display:block;padding:14px 28px;border:none;border-radius:24px;background:linear-gradient(135deg,#ffd700,#ffb700);color:#000;font-weight:700;font-size:17px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,0.3);transition:transform 0.1s;} button:active{transform: scale(0.97);} button:disabled{background-color:#cccccc;color:#fff;cursor:not-allowed;} 

✅ Cette version finale React/TypeScript inclut désormais le pinch-to-zoom tactile et la logique multi-jours, minute-level selection, buffer 75 min et bouton WhatsApp.

Si tu veux, je peux te faire une mini vidéo ou GIF de test du pinch-to-zoom + scroll horizontal infini pour être sûr que ça fonctionne exactement comme sur ton mockup.

Veux‑tu que je fasse ça ?

